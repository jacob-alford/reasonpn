// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var RList$Rationale = require("rationale/lib/js/src/RList.js");
var Option$Rationale = require("rationale/lib/js/src/Option.js");

function str(prim) {
  return prim.toString();
}

function fromNaN(n) {
  if (isNaN(n)) {
    return Option$Rationale.none(undefined);
  } else {
    return Option$Rationale.some(n);
  }
}

function rpnReducer(param, action) {
  var tape = param.tape;
  var stack = param.stack;
  if (stack) {
    var xs = stack.tl;
    var x = stack.hd;
    if (typeof action === "number") {
      return {
              stack: xs,
              tape: {
                hd: "Dropped " + x.toString(),
                tl: tape
              }
            };
    }
    switch (action.TAG | 0) {
      case /* Enter */0 :
          var a = action._0;
          return {
                  stack: {
                    hd: a,
                    tl: {
                      hd: x,
                      tl: xs
                    }
                  },
                  tape: {
                    hd: "Entered " + a.toString(),
                    tl: tape
                  }
                };
      case /* Act1 */1 :
          switch (action._0) {
            case /* Exp */0 :
                return {
                        stack: {
                          hd: Math.exp(x),
                          tl: xs
                        },
                        tape: {
                          hd: "exp(" + (x.toString() + ")"),
                          tl: tape
                        }
                      };
            case /* Sin */1 :
                return {
                        stack: {
                          hd: Math.sin(x),
                          tl: xs
                        },
                        tape: {
                          hd: "sin(" + (x.toString() + ")"),
                          tl: tape
                        }
                      };
            case /* Cos */2 :
                return {
                        stack: {
                          hd: Math.cos(x),
                          tl: xs
                        },
                        tape: {
                          hd: "cos(" + (x.toString() + ")"),
                          tl: tape
                        }
                      };
            case /* Tan */3 :
                return {
                        stack: {
                          hd: Math.tan(x),
                          tl: xs
                        },
                        tape: {
                          hd: "tan(" + (x.toString() + ")"),
                          tl: tape
                        }
                      };
            case /* Asin */4 :
                return {
                        stack: Option$Rationale.$$default(xs, Curry._2(Option$Rationale.Infix.$less$$great, fromNaN(Math.asin(x)), (function (n) {
                                    return {
                                            hd: n,
                                            tl: xs
                                          };
                                  }))),
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, fromNaN(Math.asin(x)), (function (param) {
                                    return {
                                            hd: "asin(" + (x.toString() + ")"),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Acos */5 :
                return {
                        stack: Option$Rationale.$$default(xs, Curry._2(Option$Rationale.Infix.$less$$great, fromNaN(Math.acos(x)), (function (n) {
                                    return {
                                            hd: n,
                                            tl: xs
                                          };
                                  }))),
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, fromNaN(Math.acos(x)), (function (param) {
                                    return {
                                            hd: "acos(" + (x.toString() + ")"),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Atan */6 :
                return {
                        stack: {
                          hd: Math.atan(x),
                          tl: xs
                        },
                        tape: {
                          hd: "atan(" + (x.toString() + ")"),
                          tl: tape
                        }
                      };
            
          }
      case /* Act2 */2 :
          switch (action._0) {
            case /* Add */0 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return x + y;
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: x.toString() + ("+" + y.toString()),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Sub */1 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return x - y;
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: x.toString() + ("-" + y.toString()),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Mul */2 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return x * y;
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: x.toString() + ("*" + y.toString()),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Div */3 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return y / x;
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: y.toString() + ("\xc3\xb7" + x.toString()),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* Xy */4 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return Math.pow(x, y);
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: x.toString() + ("^" + y.toString()),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* XrtY */5 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return Math.pow(y, 1.0 / x);
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: y.toString() + ("^(1/" + (x.toString() + ")")),
                                            tl: tape
                                          };
                                  })))
                      };
            case /* LogXY */6 :
                return {
                        stack: {
                          hd: Option$Rationale.$$default(x, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                      return Option$Rationale.$$default(0.0, fromNaN(Math.log(y) / Math.log(x)));
                                    }))),
                          tl: Option$Rationale.$$default(/* [] */0, RList$Rationale.tail(xs))
                        },
                        tape: Option$Rationale.$$default(tape, Curry._2(Option$Rationale.Infix.$less$$great, RList$Rationale.head(xs), (function (y) {
                                    return {
                                            hd: "log_" + (x.toString() + ("^" + y.toString())),
                                            tl: tape
                                          };
                                  })))
                      };
            
          }
      
    }
  } else {
    if (typeof action === "number") {
      return {
              stack: /* [] */0,
              tape: tape
            };
    }
    if (action.TAG) {
      return {
              stack: /* [] */0,
              tape: tape
            };
    }
    var a$1 = action._0;
    return {
            stack: {
              hd: a$1,
              tl: /* [] */0
            },
            tape: {
              hd: "Entered " + a$1.toString(),
              tl: tape
            }
          };
  }
}

var rpnInit = {
  stack: /* [] */0,
  tape: /* [] */0
};

var def = Option$Rationale.$$default;

var hd = RList$Rationale.head;

var tail = RList$Rationale.tail;

exports.rpnInit = rpnInit;
exports.str = str;
exports.def = def;
exports.hd = hd;
exports.tail = tail;
exports.fromNaN = fromNaN;
exports.rpnReducer = rpnReducer;
/* RList-Rationale Not a pure module */
